# 基本技巧

**动态规划问题的一般形式就是求最值**。

## 自顶向下

1. **确定base case**，确定我们最底层状态的返回的数值。
2. **确定状态**,确定子问题与原问题间的变量。
3. **确定选择的变量与方式**，就是如何遍历每一种选择，在自顶向下技巧里，一般是使用递归来完成。
4. **确定`dp`函数的定义**，`dp`函数的参数一般分为两种，一个是上文中提到的状态，一个是需要完成不同选择的变量集。`dp`函数值为要求的最值。
5. **利用状态方程完成`dp`函数的定义**。



```java
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
//初识情况
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变   // 所有其他情况
        result = 求最值(result, dp(状态1, 状态2, ...)) //状态转移方程
    return result



```





## 自底向上

1. **确定base case**。
2. **确定状态**。
3. **确定选择的变量与方式**，这里一般使用数组完成。
4. **确定`dp`数组的定义**，`dp`数组的索引是上文提到的状态，数组值为要求的最值。
5. **利用状态方程完成`dp`数组的运算**。



> 如何找到状态转移方程呢？一般使用数学归纳法。假设已经知道了`dp[0,1,2,......,i-1]`的值，然后求`dp[i]`的值。



> 如何判断是否有子问题重叠问题？可以把`dp`函数的细节减去，就能看出来是否有重叠，如果还是看不出来，那就画图。



> 仔细阅读题目变量的范围，可以将范围转化为特殊值，比如数组越界所需要的图书值。



```java
# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```



# 进阶技巧

## 压缩二维数组至一维数组

1. 画出数组图像，观察状态转移方程，查看二维数组投影至一维数组是否会重叠。
2. 使用临时变量记录重叠变量。
3. 查看base case 是否会重叠。（暂时没有学会如何处理重叠情况。）



## 数组`dp`函数定义总结

* 在回文子序列问题中，定义为`dp[i][j]`，`str[i]`和`str[j]`之间最长的回文串。
* **对于两个字符串求子序列的问题，都是用两个指针`i`和`j`分别在两个字符串上移动，大概率是动态规划思路**。







