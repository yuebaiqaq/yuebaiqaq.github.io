# 二分查找总结

> **总框架**

```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

## 搜索某个数值

### 闭区间写法

```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意 这里right的值决定了middle的取值范围和查找操作
    
    //当right=num.length时
    //while的判断条件是left<right
    // (right-left)/2<right-left ,so  left+(right-left)/2=middle <left+right-left=right 

    while(left <= right) {
        int mid = left + (right - left) / 2; //是为了防止数值溢出
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意   选择区间[mid+1,right]
        else if (nums[mid] > target)
            right = mid - 1; // 注意  选择区间[left,mid+1]
    }
    return -1;
}
```

### 左闭右开写法

```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length; // 注意 这里right的值决定了middle的取值范围和查找操作
    
    //当right=num.length时
    //while的判断条件是left<right
    // (right-left)/2<right-left ,so  left+(right-left)/2=middle <left+right-left=right 

    while(left < right) {
        int mid = left + (right - left) / 2; //是为了防止数值溢出
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意   选择区间[mid+1,right)
        else if (nums[mid] > target)
            right = mid ; // 注意  选择区间[left,mid)
    }
    return -1;
}
```

## 寻找边界

### 寻找左边界

> left 定位，right 移动

- ### 左闭右开写法

  ```java
  int left_bound(int[] nums, int target) {
      int left = 0;
      int right = nums.length; // 注意  
      
      while (left < right) { // 注意  [left,right)
          int mid = left + (right - left) / 2;
          if (nums[mid] == target) {
              right = mid;  //当搜索到新的位于right左边新的target值时，right过去指向它，保证了right永远指向左边界
          } else if (nums[mid] < target) {
              left = mid + 1;  //当right为target时，停止条件为left=right，所以此函数结束时，left就是指向左边界。
              				//选择到[mid+1,right)
          } else if (nums[mid] > target) {
              right = mid; // 注意   为了接近target 选择到[left,mid)
          }
      }
      return left;
  }
  
  ```

* 闭区间写法

  ```java
  int left_bound(int[] nums, int target) {
      int left = 0;
      int right = nums.length-1; // 注意  
      
      while (left <= right) { // 注意  [left,right]
          int mid = left + (right - left) / 2;
          if (nums[mid] == target) {
              right = mid-1;  //当搜索到新的位于right左边新的target值时，right过去指向它位置的左边，保证了right永远指向左边界的左边。为什么要让它指向左边呢，因为是闭区间，right容易等于mid，导致死循环，所以必须把right向左收缩
          } else if (nums[mid] < target) {
              left = mid + 1;  //当right为target左边界左边时，停止条件为left>right，所以此函数结束时，left就是指向target左边界。     选择到[mid+1,right]
          } else if (nums[mid] > target) {
              right = mid-1; // 注意   为了接近target   [left,mid-1]
          }
      }
      return left;
  }
  ```

### 寻找右边界

> **right移动，left定位。**

* ### 左闭右开写法

  ```java
  int right_bound(int[] nums, int target) {
      int left = 0, right = nums.length;
      
      while (left < right) { // [left,right)
          int mid = left + (right - left) / 2;
          if (nums[mid] == target) {
              left = mid + 1; // 注意  为了让left向右收缩到target右边界的右边，若代码为left=mid，则在特殊情况容易导致死循环，比如left和right紧挨着，他们两个都指向了target值。   
        
          } else if (nums[mid] < target) {
              left = mid + 1;// 为了接近target  选择到[mid+1,right)
          } else if (nums[mid] > target) {
              right = mid;// 常规操作    选择到[left,mid)
          }
      }
      return left - 1; // 注意   函数停止条件是left=right，所以在函数停止时，right和left都在target右边界的右边，所以返回的时候要返回left-1或者right-1
  }
  
  ```

* ### 闭区间写法

```java
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length-1;
    
    while (left <= right) { // [left,right]
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意  为了让left向右收缩到target右边界的右边，若代码为left=mid，则在特殊情况容易导致死循环，比如left和right紧挨着，他们两个都指向了target值。   
      
        } else if (nums[mid] < target) {
            left = mid + 1;// 为了接近target   选择到[mid+1,right]
        } else if (nums[mid] > target) {
            right = mid-1;// 常规操作    选择到[left,mid-1]
        }
    }
    return left - 1; // 注意   函数停止条件是left=right，所以在函数停止时，right和left都在target右边界的右边，所以返回的时候要返回left-1或者right-1
}
```

## 特殊技巧

```java
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length-1;
    
    while (left <= right) { // [left,right]
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            left = mid + 1;   
            ans=mid  //是为了记录右边界,即最后的right值。
      
        } else if (nums[mid] < target) {
            left = mid + 1;// 为了接近target   选择到[mid+1,right]
        } else if (nums[mid] > target) {
            right = mid-1;// 常规操作    选择到[left,mid-1]
        }
    }
    return mid; // 注意   返回右边界
}
```



