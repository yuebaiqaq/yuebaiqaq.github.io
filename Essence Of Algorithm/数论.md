# 求n个数的最小公倍数

求n个数的最小公倍数



【输入描述】
第一行一个数n（n<10)
下面n个数，integer范围内

【输出描述】
这n个数的最小公倍数

【样例输入】
5
6 3 5 4 2

【样例输出】
60



假设现在要求最小公倍数的两个数为x,y，他们的最大公约数为p,最小公倍数为q。则x*y=p*q,也就是说只要求得两个数的最大公约数就可求得这两个数的最小公倍数。

但是题目中要求的是n个数的 最小公倍数，这里只需要用最小公倍数代替原来的两个数即可。

例如：12      15        8         9

第一步：求得12和15的最小公倍数为60 

第二部：求得60和8的最小公倍数为120

第三步：求得120和9的最小公倍数为360

所以，原问题转换为求两个数的最大公约数。最大公约数有几种求法，第一种对于小整数的辗转相除，大整数用辗转相减，还有优化版本的辗转相减法，这里给定数字范围为int因此直接采用辗转相除法。



```c++
辗转相除求最大公约数O(lgn)
递归写法：
int gcd(int a,int b){
	if(b==0)
		return a;
	else
		return gcd(b,a%b);
}
非递归写法：
int gcd(int a,int b){
	int c;
	while(b){
		c=a;
		a=b;
		b=c%b
	}
	return a;
}
利用x*y=q*p得到最小公倍数q=x*y/p;
完整代码 O(nlg(max{arr}))：
#include<iostream>
using namespace std;
int arr[11];
int gcd(int a,int b){//两个方法任选一个
	if(b==0)
		return a;
	else
		return gcd(b,a%b);
}
int getGcd(int a,int b){
	int c;
	while(b){
		c=a;
		a=b;
		b=c%b;
	}
	return a;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>arr[i];
		if(i!=1){
			arr[i]=arr[i-1]/getGcd(arr[i-1],arr[i])*arr[i];
		}
	}
	cout<<arr[n]<<endl;
} 

```





质数又称素数。 **一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数**；否则称为合数（规定1既不是质数也不是合数）。



**整数a除以整数b(b≠0) 除得的商正好是整数而没有余数，我们就说a能被b整除，或b能整除a。** **a称为b的倍数，b称为a的约数**。



约数个数定理

对于一个大于1[正整数](https://baike.baidu.com/item/正整数/8461335?fromModule=lemma_inlink)n可以[分解质因数](https://baike.baidu.com/item/分解质因数?fromModule=lemma_inlink)：

![img](https://bkimg.cdn.bcebos.com/formula/afef3bf76b93359a0067ea80e57bca0e.svg)

则n的[正约数](https://baike.baidu.com/item/正约数/882466?fromModule=lemma_inlink)的个数就是

![img](https://bkimg.cdn.bcebos.com/formula/21c38a03ef417a187c0a202b37ce59c4.svg)

。

其中a1、a2、a3…ak是p1、p2、p3，…pk的指数。



题：正整数378000共有多少个[正约数](https://baike.baidu.com/item/正约数/882466?fromModule=lemma_inlink)？

解：将378000[分解质因数](https://baike.baidu.com/item/分解质因数/2253749?fromModule=lemma_inlink)378000=24×33×53×71

由约数个数定理可知378000共有正约数(4+1)×([3+1](https://baike.baidu.com/item/3%2B1/1202026?fromModule=lemma_inlink))×(3+1)×([1+1](https://baike.baidu.com/item/1%2B1/21620?fromModule=lemma_inlink))=160个。



```python
def is_prime3(x):
    if x == 2:
        return True
    elif x % 2 == 0:
        return False
    for i in range(3, int(x ** 0.5) + 1, 2):
        if x % i == 0:
            return False
    return True

#判断是否为质数
```



将[['a','b'],['c','d']]化为字符串

```python
import itertools
s = ''.join(list(itertools.chain.from_iterable(mp)))


    a=[[1,2],[3,4],[5,6]]  
    t=[]  
    ''.join([t.extend(i) for i in a])  
```





快速幂

```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 1:
            return x
        if n == 0:
            return 1
        if n < 0:
            return self.myPow(1/x, -n)
        return self.myPow(x, n // 2) ** 2 if n % 2 == 0 else self.myPow(x, n // 2) ** 2 * x
```



```python
distTo[i] = float('inf'), float('-inf')
```



正负无穷
