请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。

实现 `FrequencyTracker` 类：

-   `FrequencyTracker()`：使用一个空数组初始化 `FrequencyTracker` 对象。
-   `void add(int number)`：添加一个 `number` 到数据结构中。
-   `void deleteOne(int number)`：从数据结构中删除一个 `number` 。数据结构 **可能不包含** `number` ，在这种情况下不删除任何内容。
-   `bool hasFrequency(int frequency)`: 如果数据结构中存在出现 `frequency` 次的数字，则返回 `true`，否则返回 `false`。

**示例 1：**

**输入**
\["FrequencyTracker", "add", "add", "hasFrequency"\]
\[\[\], \[3\], \[3\], \[2\]
**输出**
\[null, null, null, true\]

**解释**
FrequencyTracker frequencyTracker = new FrequencyTracker();
frequencyTracker.add(3); // 数据结构现在包含 \[3\]
frequencyTracker.add(3); // 数据结构现在包含 \[3, 3\]
frequencyTracker.hasFrequency(2); // 返回 true ，因为 3 出现 2 次

>开始使用的就是数组查询，在寻找频率的时候发现已经超时了，然后换换换，发现使用双哈希表就可以，哭死。
>总结哈希表的用法：
>1.需要记录每个物品的频率的时候
>2.需要记录某样东西是否存在，这个时候的效率是最高的。


```cpp
class FrequencyTracker {
public:
    int map[100000]={};
    unordered_map<int,int>count;
    FrequencyTracker() {

    }

    void add(int number) {
        count[map[number]++]--;

        count[map[number]]++;
    }

    void deleteOne(int number) {
        if (map[number]==0)
            return;
        count[map[number]--]--;
        if (map[number]!=0)
            count[map[number]]++;
    }

    bool hasFrequency(int frequency) {
        if(count[frequency]!=0)
            return true;
        return false;

    }
};
```
