	A storekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.
	
	The game is represented by an m x n grid of characters grid where each element is a wall, floor, or box.
	
	Your task is to move the box 'B' to the target position 'T' under the following rules:
	
	The character 'S' represents the player. The player can move up, down, left, right in grid if it is a floor (empty cell).
	The character '.' represents the floor which means a free cell to walk.
	The character '#' represents the wall which means an obstacle (impossible to walk there).
	There is only one box 'B' and one target cell 'T' in the grid.
	The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.
	The player cannot walk through the box.
	Return the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1.



>题目思考
>这道题我看着就像BFS，可以试着去解决一下。
>1.首先要把小人移动到箱子的旁边，检测是否可以移动。写一写这个函数。
>2.把小人放到箱子的旁边，把箱子的位置和小人的位置放进队列里，然后进行检测，查看是否可以移动，箱子是否到达终点。
>3.



>题后思考
>其实这道题和本质上的BFS没有什么区别，只是我们需要考虑把我们不熟悉的题变成我们所熟悉的题。
>标准的BFS：棋盘上只有墙、目的地、人，如果有箱子和人这两种事务，那就把他们归为一种状态。
>而且经过这道题我认识到DFS的一个本质上的问题，我们在BFS走的每一步，然后把这一步放入队列这一步骤的目的，是有玄机的。因为你是把每一步的下一步每种可能都入队列，导致队列中就有一个隐形条件，那就是队列中是按步数的多少进行排序的。如果题目求得不是步数，那我们就需要另加考虑了。


Example 1:
![[sample_1_1620.png]]

Input: grid = [["#","#","#","#","#","#"],
               ["#","T","#","#","#","#"],
               ["#",".",".","B",".","#"],
               ["#",".","#","#",".","#"],
               ["#",".",".",".","S","#"],
               ["#","#","#","#","#","#"]]
Output: 3
Explanation: We return only the number of times the box is pushed.




```cpp
  
#include <iostream>  
#include <vector>  
#include <algorithm>  
#include <string>  
#include <unordered_map>  
#include <algorithm>  
#include <cmath>  
#include <set>  
#include<queue>  
using namespace std;  
  
class Solution {  
public:  
  
int minPushBox(vector<vector<char>>& grid) {  
priority_queue<vector<size_t>,vector<vector<size_t>>,greater<vector<size_t>>> pq;  
size_t m=grid.size();  
size_t n=grid[0].size();  
  
vector<size_t> a(5, 0);  
for (size_t x = 0; x < m; x++)  
{  
for (size_t y = 0; y < n; y++)  
{  
if (grid[x][y] == 'S')  
{  
a[1] = x;  
a[2] = y;  
grid[x][y] = '.';  
}  
else if (grid[x][y] == 'B')  
{  
a[3] = x;  
a[4] = y;  
grid[x][y] = '.';  
}  
}  
}  
pq.push(a);  
  
set<vector<size_t>> dist;  
dist.insert({ a[1], a[2], a[3], a[4] });  
  
int dx[4] = { 0,0,1,-1 };  
int dy[4] = { 1,-1,0,0 };  
  
  
while (!pq.empty()){  
auto v=pq.top();  
pq.pop();  
  
for(int i=0;i<4;i++)  
{  
  
vector<size_t> next_s = {v[1] + dx[i], v[2] + dy[i]};  
if (next_s[0] >= m || next_s[1] >= n || grid[next_s[0]][next_s[1]] == '#') {  
continue;  
}  
vector<size_t>next_b={v[3],v[4]};  
size_t d=v[0];  
if (next_s == next_b)  
{  
next_b[0] += dx[i];  
next_b[1] += dy[i];  
if (next_b[0] >= m || next_b[1] >= n || grid[next_b[0]][next_b[1]] == '#')  
{  
continue;  
}  
d++;  
}  
  
if (grid[next_b[0]][next_b[1]] == 'T')  
{  
return (int)d;  
}  
if (dist.find({next_s[0], next_s[1], next_b[0], next_b[1]}) != dist.end())  
{  
continue;  
}  
dist.insert({ next_s[0], next_s[1], next_b[0], next_b[1] });  
pq.push({ d, next_s[0], next_s[1], next_b[0], next_b[1] });  
}  
  
  
  
}  
  
return -1;  
  
}  
};  
  
int main() {  
vector<vector<char>> grid = {{'#', '#', '#', '#', '#', '#'},  
{'#', 'T', '#', '#', '#', '#'},  
{'#', '.', '.', 'B', '.', '#'},  
{'#', '.', '#', '#', '.', '#'},  
{'#', '.', '.', '.', 'S', '#'},  
{'#', '#', '#', '#', '#', '#'}};  
  
  
  
Solution s;  
cout << s.minPushBox(grid);  
  
}
```
