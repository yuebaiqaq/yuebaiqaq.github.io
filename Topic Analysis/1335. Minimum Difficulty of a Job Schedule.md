2023-05-16 
>"Your presence in my life is a constant source of happiness and inspiration. I feel so blessed to have you by my side, and I promise to cherish and love you for [[eternity]]."
# Question Stem
You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 <= j < i).

You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day.

You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i].

Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.

# Test Case
## **Example 1:**



## **Example 2:**

## **Example 3:**




# Constraints:





# Process of Reflection
>

# Code

# My answer


## Gold's answer
>一看到将数组分成若干份，求每份某个属性之和的最值就可以想到“I型区间DP”，套路很固定
状态定义
>dp\[i\]\[k]表示将\[0,i\]分成k份得到的最低难度
状态转移
>将\[0,j\]分成k-1份，\[j+1,i\]自成一份，有状态转移方程dp\[i\]\[k\]=min(dp\[j\]\[k-1\]+rangeMax\[j+1\]\[i\])。
>一般来说，自成一份的那个属性（本题中是rangeMax）需要预处理出来。rangeMax\[l\]\[r\]表示\[l,r\]的区间最值，它可以由rangeMax\[l\]\[r-1\]和jobDifficulty\[r\]两部分求得，rangeMax\[l\]\[r\]=max(rangeMax\[l\]\[r-1\], jobDifficulty\[r\])。
```cpp
const int N = 310;
int dp[N][N];

class Solution {
public:
    int minDifficulty(vector<int>& jobDifficulty, int d) {
        int n = jobDifficulty.size();
        if(d > n) return -1;
        vector<vector<int>> rangeMax(n, vector<int>(n));
        for(int i = 0; i < n; i++) rangeMax[i][i] = jobDifficulty[i];
        for(int len = 2; len <= n; len++) {
            for(int l = 0; l + len - 1 < n; l++) {
                int r = l + len - 1;
                rangeMax[l][r] = max(rangeMax[l][r - 1], jobDifficulty[r]);
            }
        }
        memset(dp, 0x3f, sizeof dp);
        for(int i = 0; i < n; i++) {
            dp[i][1] = rangeMax[0][i];
        }
        for(int i = 0; i < n; i++) {
            for(int k = 2; k <= min(i + 1, d); k++) {
                for(int j = 0; j < i; j++) {
                    dp[i][k] = min(dp[i][k], dp[j][k - 1] + rangeMax[j + 1][i]);
                }
            }
        }
        return dp[n - 1][d];
    }
};

```


>![image.png](https://raw.githubusercontent.com/yuebaiqaq/Image/master/image/20230516221713.png)




```cpp
class Solution {

public:

    int minDifficulty(vector<int>& jobDifficulty, int d) {

        int n = jobDifficulty.size();

        if (n < d) {

            return -1;

        }

        vector<vector<int>> dp(d + 1, vector<int>(n, 0x3f3f3f3f));

        int ma = 0;

        for (int i = 0; i < n; ++i) {

            ma = max(ma, jobDifficulty[i]);

            dp[0][i] = ma;

        }

        for (int i = 1; i < d; ++i) {

            for (int j = i; j < n; ++j) {

                ma = 0;

                for (int k = j; k >= i; --k) {

                    ma = max(ma, jobDifficulty[k]);

                    dp[i][j] = min(dp[i][j], ma + dp[i - 1][k - 1]);

                }

            }

        }

        return dp[d - 1][n - 1];

    }

};
```