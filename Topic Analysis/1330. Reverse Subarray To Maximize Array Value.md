2023-05-12 
>"Your presence in my life is a constant source of happiness and inspiration. I feel so blessed to have you by my side, and I promise to cherish and love you for eternity."
# Question Stem

You are given an integer array nums. The value of this array is defined as the sum of |nums\[i\] - nums\[i + 1\]| for all 0 <= i < nums.length - 1.

You are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.

Find maximum possible value of the final array.



# Test Case
## **Example 1:**
Input: nums = \[2,3,1,5,4\]
Output: 10
Explanation: By reversing the subarray \[3,1,5\] the array becomes\[2,5,1,3,4\] whose value is 10.

## **Example 2:**
**Input:** nums = \[2,4,9,24,2,1,10\
**Output:** 68

# Constraints:

-   `1 <= nums.length <= 3 * 104`
-   `-105 <= nums[i] <= 105`




# Process of Reflection
>Upon encountering the [[enigmatic]] question, I [[discerned]] that the [[crux]] of solving it [[lies in]] the subarray's boundaries. It became apparent that the subarray, while preserving its contents, remains unchanged when reversed except for its boundaries.
>However, it seems that my line of thinking was [[misguided]], and the chosen algorithmic approach is rather [[arduous]] and time-consuming.”

# Code

# My answer


## Gold's answer

[灵神的链接](https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/solution/bu-hui-hua-jian-qing-kan-zhe-pythonjavac-c2s6/)


```cpp
class Solution {

public:

    int maxValueAfterReverse(vector<int> &nums) {

        int base = 0, d = 0, mx = INT_MIN, mn = INT_MAX, n = nums.size();

        for (int i = 1; i < n; i++) {

            int a = nums[i - 1], b = nums[i];

            base += abs(a - b);

            mx = max(mx, min(a, b));

            mn = min(mn, max(a, b));

            d = max(d, max(abs(nums[0] - b) - abs(a - b), // i=0

                           abs(nums[n - 1] - a) - abs(a - b))); // j=n-1

        }

        return base + max(d, 2 * (mx - mn));

    }

};
```



	qqq