2023-05-13 
>"Your presence in my life is a constant source of happiness and inspiration. I feel so blessed to have you by my side, and I promise to cherish and love you for eternity."
# Question Stem
Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.

Return the positive integer k. If there is no such integer, return -1.


# Test Case
## **Example 1:**
Input: nums = \[-1,2,-3,3\]
Output: 3
Explanation: 3 is the only valid k we can find in the array.

## **Example 2:**
Input: nums = \[-1,10,6,7,-7,1\]
Output: 7
Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.

## **Example 3:**

Input: nums = \[-10,8,6,7,-2,-3\]
Output: -1
Explanation: There is no a single valid k, we return -1.



# Constraints:
-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`
-   `nums[i] != 0`



# Process of Reflection
>It's a qusetion of using hash table to tackle when I read the stem.So I can solvo it quickly.

# Code

# My answer

```cpp
class Solution {

public:

    int findMaxK(vector<int>& nums) {

        unordered_map<int,int>digit;

        int maxs=-1;

        for(auto i :nums){

            if(digit[(-i)]!=0)

                maxs= max(maxs,abs(i));

            digit[(i)]++;

        }

        return maxs;

    }

};
```


## Gold's answer



```cpp
class Solution {
public:
    int findMaxK(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 0, j = nums.size() - 1; i < j; j--) {
            while (i < j && nums[i] < -nums[j]) {
                i++;
            }
            if (nums[i] == -nums[j]) {
                return nums[j];
            }
        }
        return -1;
    }
};
```
