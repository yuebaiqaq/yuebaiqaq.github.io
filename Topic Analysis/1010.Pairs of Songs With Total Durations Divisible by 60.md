You are given a list of songs where the ith song has a duration of time[i] seconds.
	
	Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i < j with (time[i] + time[j]) % 60 == 0.

 
Example 1:

Input: time = \[30,20,150,100,40\]
Output: 3
[[Explanation]]: Three pairs have a total duration divisible by 60:
(time\[0\] = 30, time\[2\] = 150): total duration 180
(time\[1\] = 20, time\[3\] = 100): total duration 120
(time\[1\] = 20, time\[4\] = 40): total duration 60


Example 2:

Input: time = \[60,60,60\]
Output: 3
Explanation: All three pairs have a total duration of 120, which is divisible by 60.


-   `1 <= time.length <= 6 * 104`
-   `1 <= time[i] <= 500`



思考：这道题应该是考了取模问题，想一想问题所在，`(x+y)mod60=0`，在这里如果是顺序循环的话，只能兼顾一个x，所以要找出x和y的关系，经过推导可得出`y=(60-x)mod60`，就可以进行判断了，但是双层循环的时间复杂度过高，所以我们可以考虑简化成单层循环。
在单层循环里，我们要找到如何一次就能计算完成每个数字的对应操作呢？我们可以尝试着把每个数字的对应60的数字出现的次数加起来，查找每次循环的数字，第一次查找的结果肯定是0，第二次查找到的结果就可以加到ans上了。




```cpp
class Solution {

public:

    int numPairsDivisibleBy60(vector<int>& time) {

        int count=0;

        int cnt[60]={0};

        for(int i:time){

            i%=60;

            int y=(60-i)%60;

            count+=cnt[y];

            cnt[i]++;

        }

        return count;

    }

};
```